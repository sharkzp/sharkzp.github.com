<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: best practices | Root of Evil]]></title>
  <link href="http://sharkzp.github.io/blog/categories/best-practices/atom.xml" rel="self"/>
  <link href="http://sharkzp.github.io/"/>
  <updated>2013-12-16T18:25:03+02:00</updated>
  <id>http://sharkzp.github.io/</id>
  <author>
    <name><![CDATA[Alex Topalov]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Callbacks Extraction]]></title>
    <link href="http://sharkzp.github.io/blog/2013/12/16/callbacks-extraction/"/>
    <updated>2013-12-16T17:22:00+02:00</updated>
    <id>http://sharkzp.github.io/blog/2013/12/16/callbacks-extraction</id>
    <content type="html"><![CDATA[<p>{% blockquote Edsger W. Dijkstra <a href="http://www.u.arizona.edu/~rubinson/copyright_violations/Go_To_Considered_Harmful.html">http://www.u.arizona.edu/~rubinson/copyright_violations/Go_To_Considered_Harmful.html</a> %}</p>

<p>The unbridled use of the go to statement has an immediate consequence that it becomes terribly hard to find a meaningful set of coordinates in which to describe the process progress.</p>

<p>{% endblockquote %}</p>

<p>Rails provide powerful callback technique and as a powerful tool it could injure in newbie hands.</p>

<!-- more -->


<h3>Understanding the problem</h3>

<p>For example we have simple blog engine. Where we have <code>Posts, Users, Comments</code>
And system should create a default post with random comments when <code>User</code> with type <code>admin</code> created. This could be done through rails callbacks</p>

<p>{% codeblock lang:ruby%}
class User &lt; ActiveRecord::Base
  after_create :create_post, if: :admin?</p>

<p>  private
  def create_post</p>

<pre><code>posts &lt;&lt; Post.create(default_post_attributes)
</code></pre>

<p>  end
end</p>

<p>class Post &lt; ActiveRecord::Base
  after_create :create_comments</p>

<p>  private
  def create_comments</p>

<pre><code>comments &lt;&lt; Comment.create(defaul_comment_attributes)
</code></pre>

<p>  end
end</p>

<p>class Comment &lt; ActiveRecord::Base
  before_create :ensure_user_existance</p>

<p>  private
  def ensure_user_existance</p>

<pre><code>unless user
  user = User.create(default_user_attrubutes)
end
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>After some time passed you decide that creating user for comments was a bad idea and you remove it.
But when you create another one admin you need to search through three different objects to find out why your default post does not have comments. This is the simplest example but you could find even more weird problems and real hell in practice.</p>

<h3>Solution</h3>

<p>For extracting this behavior out of objects we need to keep in mind some of best practices. Sandi Matz recommends to keep your objects unitary and easy to follow check out <a href="http://robots.thoughtbot.com/sandi-metz-rules-for-developers">this</a> blog post for more details.</p>

<p>So lets introduce new object that for now will encapsulate logic around admin user</p>

<p>{% codeblock lang:ruby%}
class AdminUser
  def save</p>

<pre><code>user.save
create_post
</code></pre>

<p>  end</p>

<p>  private
  def create_post</p>

<pre><code>posts &lt;&lt; Post.create(comments: [Comment.create(user: user)])
</code></pre>

<p>  end
end</p>

<p>class User &lt; ActiveRecord::Base
end</p>

<p>class Post &lt; ActiveRecord::Base
end</p>

<p>class Comment &lt; ActiveRecord::Base
end
{% endcodeblock %}</p>

<p>This way we could extract any kind of callbacks out of User class that belongs to specific type of user of certain conditions.</p>

<p>{% codeblock lang:ruby%}
class AdminUser
  attr_reader :attributes</p>

<p>  def initialize(options = {})</p>

<pre><code>before_initialize
attributes = options[:user]
after_initialize
</code></pre>

<p>  end</p>

<p>  def save</p>

<pre><code>before_save
user.save
after_save
</code></pre>

<p>  end</p>

<p>  private
  def user</p>

<pre><code>User.new(attributes)
</code></pre>

<p>  end</p>

<p>  #&hellip;
end
{% endcodeblock %}</p>

<p>I recommend to always keep your objects as clean and small as possible, so any changes that you need to introduce touch single class that easy to understand and follow.</p>

<h3>Resume</h3>

<p>Extracting callbacks out of Domain Class could be useful refactoring technique and any of us should use to avoid callback hells and code smells. Unitary class is much easier to test and change.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Refactoring Wrappers]]></title>
    <link href="http://sharkzp.github.io/blog/2013/08/25/refactoring-wrappers/"/>
    <updated>2013-08-25T20:11:00+03:00</updated>
    <id>http://sharkzp.github.io/blog/2013/08/25/refactoring-wrappers</id>
    <content type="html"><![CDATA[<h3>Introduction</h3>

<p>Very often in my everyday practice I faced a task when you need to create a communication between your own services or some 3rd party service that don&rsquo;t have a implementation yet. So what is the best way to doing that?</p>

<p>{% blockquote %}
Wrapper &ndash; it is a piece of code that will be responsible for communication between your application and external service.
{% endblockquote %}</p>

<!-- more -->


<h3>Identicating problem</h3>

<p>When you have a task that implies creation of wrapper you could came up with the easiest solution like:</p>

<p>{% codeblock lang:ruby%}
class ServiceWrapper
  def self.server_rise(server)</p>

<pre><code>request = Net::HTTP.post_form(URI(Settings.service_url + "server_rise"), { server_name: server.name })
if request['success']
  true
else
  false
end
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>But as everyone knew requirements are changes often :) So this could be finished like this:</p>

<p>{% codeblock lang:ruby%}
class ServiceWrapper
  def self.server_rise(server)</p>

<pre><code>request = Net::HTTP.post_form(service_url("server_rise"), { server_name: server.name })
if request['success']
  true
else
  false
end
</code></pre>

<p>  end</p>

<p>  def self.add_platform(platform)</p>

<pre><code>request = Net::HTTP.post_form(service_url("add_platform"), { platform: platform.name})
if request['success']
  request['response']
else
  false
end
</code></pre>

<p>  end</p>

<p>  def self.platform_rise(platform)</p>

<pre><code>request = Net::HTTP.post_form(service_url("platform_rise"), { platform: platform.name})
if request['success']
  true
else
  false
end
</code></pre>

<p>  end</p>

<p>  def exceed_storage(server)</p>

<pre><code>request = Net::HTTP.post_form(service_url("exceed_storage"), { server_name: server.name })
if request['success']
  request['response']
else
  false
end
</code></pre>

<p>  end</p>

<p>  def three_fourths_traffic(server)</p>

<pre><code>request = Net::HTTP.post_form(service_url("three_fourths_traffic"), { server_name: server.name })
if request['success']
  request['response']
else
  false
end
</code></pre>

<p>  end</p>

<p>  def exceed_traffic(server)</p>

<pre><code>request = Net::HTTP.post_form(service_url("exceed_traffic"), { server_name: server.name })
if request['success']
  request['response']
else
  false
end
</code></pre>

<p>  end</p>

<p>  def server_down(server)</p>

<pre><code>request = Net::HTTP.post_form(service_url("server_down"), { server_name: server.name })
if request['success']
  request['response']
else
  false
end
</code></pre>

<p>  end</p>

<p>  private
  def self.service_url(url, options)</p>

<pre><code>URI(Settings.service_url + command)
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>This doesn&rsquo;t even looks like a object oriented approach, this is complete mess that could be extended became even worse. So what we could do about that?</p>

<h3>Understanding problem</h3>

<p>When you develop application especially application in ruby(You remember that this is Object Oriented language, right?) you should keep in mind what objects you create and how messages goes thought them. Let&rsquo;s indicate our objects regarding this task scope:</p>

<ul>
<li>Server</li>
<li>Platform</li>
<li>Notification</li>
</ul>


<p>So basically we have:</p>

<ul>
<li>Initiate Server creation ( isn&rsquo;t this sounds like <code>Object#new</code>? )</li>
<li>Server down ( isn&rsquo;t this changing the state of object ? )</li>
<li>Same for platform</li>
<li>Simple notifications that actually could be treated exactly how you think about your <a href="http://guides.rubyonrails.org/action_mailer_basics.html">mailers</a></li>
</ul>


<h3>Solution</h3>

<p>Now we see what objects we have, lets write simple implementations for <code>Server</code>.</p>

<p>{% codeblock lang:ruby%}
class Wrapper::Server
  def new(server)</p>

<pre><code>@server = server
</code></pre>

<p>  end</p>

<p>  def self.save!</p>

<pre><code>response = Wrapper::Request.post("server_rise", server_name: @server.name)
response.success?
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>From your code it will looks like this <code>Wrapper::Server.new(@server).save!</code> name it as a <code>wrapper</code> is a bad idea, so you should probably name it with a service_name and add Wrapper and the end if necessary. Let&rsquo;s see how <code>request</code> will looks like:</p>

<p>{% codeblock lang:ruby%}
module Wrapper::Request
  class Error &lt; StandardError; end</p>

<p>  def self.post(url, params = {})</p>

<pre><code>response = RestClient.post(Settings.service_url + url, params.to_json, content_type: :json, accept: :json)
Wrapper::Response.new(response.body)
</code></pre>

<p>  rescue RestClient::Exception => e</p>

<pre><code>Wrapper::Response.new(e.response)
</code></pre>

<p>  rescue Errno::ECONNREFUSED => e</p>

<pre><code>raise Wrapper::Request::Error, "Service is down"
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>And <code>response</code></p>

<p>{% codeblock lang:ruby%}
class Wrapper::Response
  def initialize(json_body)</p>

<pre><code>json_body = json_body
</code></pre>

<p>  end</p>

<p>  def success?</p>

<pre><code>!!json_body['response']
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>This is just a proof of concept that will give your a direction in which you should move on. Now you will works with objects instead of hacks.</p>

<h3>Conclusion</h3>

<p>You should always treat your messages as a communication between objects. Even if coding in this way takes more time. But the more time your spend today the less time you will need to spend in future.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[All about Duck Types]]></title>
    <link href="http://sharkzp.github.io/blog/2013/06/16/all-about-duck-types/"/>
    <updated>2013-06-16T23:26:00+03:00</updated>
    <id>http://sharkzp.github.io/blog/2013/06/16/all-about-duck-types</id>
    <content type="html"><![CDATA[<h3>Introduction</h3>

<p>I heard a lot about Duck Types in Rails but I have never saw how can I used in a real-time application.
Today I will show you how to use duck types in examples.</p>

<p>{% blockquote %}
Duck Typing is a style of dynamic typing in which an object&rsquo;s methods and properties determine the valid semantics, rather than its inheritance from a particular class or implementation of a specific interface.
{% endblockquote %}</p>

<!-- more -->


<p>This sounds a bit weird for me, lets make an example.
For instance you have a class that responsible for generating some View-presenter data according to objects that you pass</p>

<p>{% codeblock lang:ruby %}
  class Presenter</p>

<pre><code>def description(subject)
  case subject
  when Post
    subject.as_json.merge!(commets_counter: true)
  when WallPost
    subject.to_hash.merge!(commets_counter: true)
  when Video
    subject.attributes.merge!(title: 'some title')
  when Audio
    subject.to_json
  when NilClass
    nil
  else
    raise ArgumentError
  end
end
</code></pre>

<p>  end
{% endcodeblock %}</p>

<h2>What&rsquo;s wrong?</h2>

<p>In some day you could came up to such solution. And on what you should take a look
This violates SOLID principles.</p>

<ol>
<li>Why presenter class should know about view representation about each class?</li>
<li>We did not make any modifications with data that came up from class, than why we cannot move this method to class itself?</li>
</ol>


<p>Let&rsquo;s refactoring this:
{% codeblock lang:ruby %}
class Presenter
  def description(subject)</p>

<pre><code>case subject
when Post
  subject.description
when WallPost
  subject.description
when Account
  subject.description
when Video
  subject.description
when Audio
  subject.description
when NilClass
  nil
else
  raise ArgumentError
end
</code></pre>

<p>  end
end</p>

<h1>For other classes this will be similar to</h1>

<p>class Post
  def self.description</p>

<pre><code>as_json.merge!(commets_counter: true)
</code></pre>

<p>  end
end
{% endcodeblock %}
If subject will not implement description than rails will raise an exception.
Next iteration of refactoring
{% codeblock lang:ruby %}
class Presenter
  def description(subject)</p>

<pre><code>subject.description
</code></pre>

<p>  end
end
{% endcodeblock %}
Congratulation you successfully implement Duck type :)
But now our presenter looks like <a href="http://sourcemaking.com/refactoring/lazy-class">lazy class</a>.
So this class could be totally removed.</p>

<h2>Resume</h2>

<p>If something looks like a duck and quack like a duck than it is a duck.
Also it will be good to test such Ducks using rspec <a href="https://www.relishapp.com/rspec/rspec-core/docs/example-groups/shared-examples">shared_examples</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Monads the heart of the matter]]></title>
    <link href="http://sharkzp.github.io/blog/2013/04/27/monads-the-heart-of-the-matter/"/>
    <updated>2013-04-27T12:33:00+03:00</updated>
    <id>http://sharkzp.github.io/blog/2013/04/27/monads-the-heart-of-the-matter</id>
    <content type="html"><![CDATA[<h3>Introduction</h3>

<p>Monads came form functional programming like Haskell. And this is not a secret from no-one that Ruby takes some parts from this languages.
So, what is Monad about?</p>

<p>{% blockquote %}
Monad is a structure that represents computations. This allows the programmer to build pipelines that process data in steps, in which each action is decorated with additional processing rules provided by the monad. Today we will create monad and see how it will help us.
{% endblockquote %}</p>

<!-- more -->


<p>Monad is made up of three things:</p>

<ul>
<li>Container for a value.</li>
<li>Wrap the parameter into instance of monad.</li>
<li>Binding functions to the container.</li>
</ul>


<p>Let&rsquo;s create it step by step
{% codeblock lang:ruby%}
class Monad
  def initialize(value)</p>

<pre><code>@v = value
</code></pre>

<p>  end</p>

<p>  def unit(value)</p>

<pre><code>self.class.new(value)
</code></pre>

<p>  end</p>

<p>  def bind(f)</p>

<pre><code>self.unit(f.call(@v))
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>It will produce
{% codeblock lang:ruby%}
  h = { a: { c: { d: { e: 4 } } } }
  Monad.new(h).bind(lambda{|c| c.fetch(:a)}).bind(lambda{|c| c.fetch(:c)})
  #=> {:d=>{:e=>4}}</p>

<p>  v = 10
  Monad.new(v).bind(lambda{|c| c**2 }).bind(lambda{|c| c / 2 })
  #=> 50
{% endcodeblock %}</p>

<p>This is the basic realization of IO Monads.</p>

<h3>There are few other types.</h3>

<ol>
<li>IO Monad &ndash; take result from first function and pass it to second.</li>
<li>Maybe &ndash; if first function return value than pass it to second function, otherwise return nil. This one implemented as a gem <a href="https://github.com/pzol/monadic">This link</a>.</li>
<li>Either monad &ndash; if function will fail it will return Failure object, otherwise it will return success. This used for handling errors and fighting exceptions.
And others.</li>
</ol>


<h3>Simple implementation of Maybe monad</h3>

<p>{% codeblock lang:ruby%}
class Monad
  def initialize(value)</p>

<pre><code>@v = value
</code></pre>

<p>  end</p>

<p>  def unit(value)</p>

<pre><code>self.class.new(value)
</code></pre>

<p>  end</p>

<p>  def bind(f)</p>

<pre><code>begin
  self.unit(f.call(@v))
rescue
  self.unit(nil)
end
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>It will produce
{% codeblock lang:ruby%}
h1 = { a: { c: { d: { e: 4 } } } }
h2 = {}
f1 = lambda {|c| c.fetch(:a) }
f2 = lambda {|c| c.fetch(:c) }
f3 = lambda {|c| c.fetch(:d) }
f4 = lambda {|c| c.fetch(:e) }</p>

<p>Monad.new(h1).bind(f1).bind(f2).bind(f3).bind(f4)</p>

<h1>=> 4</h1>

<p>Monad.new(h2).bind(f1).bind(f2).bind(f3).bind(f4)</p>

<h1>=> nil</h1>

<p>{% endcodeblock %}
This way you could avoid exception handling in you applications that depend on external request
For example
{% codeblock lang:ruby%}
class TwitterCallbackController &lt; ActionController::Base
  def create</p>

<pre><code>if partner_uuid = Monad.new(request).fetch(:body).fetch(:partner_uuid)
  User.authenticate_by_uuid(partner_uuid)
end
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<h3>Other fields of interest:</h3>

<ul>
<li>Fetching Data from Database</li>
<li>Processing XML/SOAP results</li>
<li>Complex calculations</li>
<li>etc</li>
</ul>


<h2>Resume</h2>

<p>Monad its a powerful technique that could be used in your application in various places. But it could encapsulate some intermediate results that you may want to see. For example error handling could be more useful when you will see real answer from 3rd party applications.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Don't use STI in your Rails Apps]]></title>
    <link href="http://sharkzp.github.io/blog/2013/04/20/dont-use-sti-in-your-rails-apps/"/>
    <updated>2013-04-20T11:33:00+03:00</updated>
    <id>http://sharkzp.github.io/blog/2013/04/20/dont-use-sti-in-your-rails-apps</id>
    <content type="html"><![CDATA[<p>{% blockquote Sincerely Your Wiki <a href="http://en.wikipedia.org/wiki/Single_Table_Inheritance">http://en.wikipedia.org/wiki/Single_Table_Inheritance</a> %}</p>

<p>Single table inheritance is a way to emulate object-oriented inheritance in a
relational database. When mapping from a database table to an object in an
object-oriented language, a field in the database identifies what class in the hierarchy the object belongs to</p>

<p>{% endblockquote %}</p>

<p>Single Table Inheritance(STI) is a useful and sharp technique,
and like any other high level instrument you should use it in an appropriate place.
Let&rsquo;s take a closer look with examples</p>

<!-- more -->


<p>For example you have a Blog, inside this blog you will have for sure such objects:</p>

<ul>
<li>Image</li>
<li>User Avatar</li>
<li>Comments Attachments</li>
</ul>


<p>First thing that you should create is a table from which you will inherit:</p>

<p>{% codeblock lang:ruby%}</p>

<h1>app/models/asset.rb</h1>

<p>class Asset &lt; ActiveRecord::Base
  # Fields:</p>

<pre><code>#   String attachment
#   String type
</code></pre>

<p>end</p>

<h1>app/models/image.rb</h1>

<p>class Image &lt; Asset
  mount_uploader :attachment, ImageUploader
end</p>

<h1>app/models/avatar.rb</h1>

<p>class Avatar &lt; Asset
  mount_uploader :attachment, AvatarUploader
end</p>

<h1>app/models/comment_attachment.rb</h1>

<p>class CommentAttachment &lt; Asset
  mount_uploader :attachment, CommentAttachmentUploader
end
{% endcodeblock %}</p>

<h3>Let&rsquo;s see what will happens in terminal:</h3>

<p>{% codeblock lang:ruby%}
  1.9.3-p194 :001 > asset = Asset.create
  => #<Asset id: 1, type: nil, attachment: nil></p>

<p>  1.9.3-p194 :004 > comment_attachment = CommentAttachment.create
  => #<CommentAttachment id: 4, type: "CommentAttachment", attachment: nil></p>

<p>  1.9.3-p194 :006 > Asset.select(&lsquo;id, type&rsquo;)
  => [#<Asset id: 1, type: nil>, #<Image id: 2, type: "Image">, #<Avatar id: 3, type: "Avatar">, #<CommentAttachment id: 4, type: "CommentAttachment">]
{% endcodeblock %}</p>

<h3>How does it work?</h3>

<p>{% blockquote <a href="http://api.rubyonrails.org/classes/ActiveRecord/Base.html">http://api.rubyonrails.org/classes/ActiveRecord/Base.html</a> %}
Active Record allows inheritance by storing the name of the class in a column that by default is named “type” (can be changed by overwriting Base.inheritance_column)
{% endblockquote %}</p>

<p>So when you inherit from some table your child tables will insert class name in <code>type</code> column.
This looks good, you create one table, make an abstraction and right now everything work nice.
When you will specify each uploader you could create different behavior and image size(I will not cover it in this post feel free to visit <a href="https://github.com/jnicklas/carrierwave">This link</a>)
You could go to your boss and say they your are awesome :)</p>

<h2>Where is the evil?</h2>

<p>What will happens when you will create a User?
{% codeblock lang:ruby%}</p>

<h1>app/models/user.rb</h1>

<p>class User &lt; ActiveRecord::Base
  has_one :avatar
end</p>

<h1>app/models/avatar.rb</h1>

<p>class Avatar &lt; Asset
  belongs_to :user
end
{% endcodeblock %}</p>

<p>You should add <code>user_id</code> to your asset table.
Oh, yes you also need a <code>Post</code>, that will include <code>Images</code>, and yes you have a <code>Comments</code>, that attach to you <code>CommentAttachment</code>.
And in the end you will face this kind of scheme:
{% codeblock lang:ruby%}
  create_table &ldquo;assets&rdquo;, :force => true do |t|</p>

<pre><code>t.string   "type"
t.string   "attachment"
t.string   "user_id"
t.string   "post_id"
t.string   "comment_id"
t.string   "commentator_id"
t.datetime "created_at", :null =&gt; false
t.datetime "updated_at", :null =&gt; false
</code></pre>

<p>  end
{% endcodeblock %}</p>

<p>Half of your table will be filled with <code>NULL</code>.
Maybe someday you will decide to use your <code>CommentAttachment</code> for attaching <code>Audio</code> and <code>video</code>?
{% codeblock lang:ruby%}
  create_table &ldquo;assets&rdquo;, :force => true do |t|</p>

<pre><code>t.string   "type"
t.string   "attachment"
t.string   "user_id"
t.string   "post_id"
t.string   "comment_id"
t.string   "commentator_id"
t.string   "audio_bitrate"
t.string   "thumbnail"
t.boolean  "is_in_gallery" #for cases when you create a gallery of images
t.string   "artist"
t.string   "album"
t.integer  "year"
t.string   "genre"
t.integer  "bitrate"

t.datetime "created_at", :null =&gt; false
t.datetime "updated_at", :null =&gt; false
</code></pre>

<p>  end
{% endcodeblock %}</p>

<p>Right now your table will looks like a crap. And your project will became soo huge that you could not to refactoring well.</p>

<h2>Conclusion</h2>

<p>Use STI only when you totally sure that you will never change it.
This post based on a true story.</p>
]]></content>
  </entry>
  
</feed>
