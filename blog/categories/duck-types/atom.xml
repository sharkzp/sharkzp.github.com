<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Duck types | Root of Evil]]></title>
  <link href="http://sharkzp.github.io/blog/categories/duck-types/atom.xml" rel="self"/>
  <link href="http://sharkzp.github.io/"/>
  <updated>2013-12-16T18:25:03+02:00</updated>
  <id>http://sharkzp.github.io/</id>
  <author>
    <name><![CDATA[Alex Topalov]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[All about Duck Types]]></title>
    <link href="http://sharkzp.github.io/blog/2013/06/16/all-about-duck-types/"/>
    <updated>2013-06-16T23:26:00+03:00</updated>
    <id>http://sharkzp.github.io/blog/2013/06/16/all-about-duck-types</id>
    <content type="html"><![CDATA[<h3>Introduction</h3>

<p>I heard a lot about Duck Types in Rails but I have never saw how can I used in a real-time application.
Today I will show you how to use duck types in examples.</p>

<p>{% blockquote %}
Duck Typing is a style of dynamic typing in which an object&rsquo;s methods and properties determine the valid semantics, rather than its inheritance from a particular class or implementation of a specific interface.
{% endblockquote %}</p>

<!-- more -->


<p>This sounds a bit weird for me, lets make an example.
For instance you have a class that responsible for generating some View-presenter data according to objects that you pass</p>

<p>{% codeblock lang:ruby %}
  class Presenter</p>

<pre><code>def description(subject)
  case subject
  when Post
    subject.as_json.merge!(commets_counter: true)
  when WallPost
    subject.to_hash.merge!(commets_counter: true)
  when Video
    subject.attributes.merge!(title: 'some title')
  when Audio
    subject.to_json
  when NilClass
    nil
  else
    raise ArgumentError
  end
end
</code></pre>

<p>  end
{% endcodeblock %}</p>

<h2>What&rsquo;s wrong?</h2>

<p>In some day you could came up to such solution. And on what you should take a look
This violates SOLID principles.</p>

<ol>
<li>Why presenter class should know about view representation about each class?</li>
<li>We did not make any modifications with data that came up from class, than why we cannot move this method to class itself?</li>
</ol>


<p>Let&rsquo;s refactoring this:
{% codeblock lang:ruby %}
class Presenter
  def description(subject)</p>

<pre><code>case subject
when Post
  subject.description
when WallPost
  subject.description
when Account
  subject.description
when Video
  subject.description
when Audio
  subject.description
when NilClass
  nil
else
  raise ArgumentError
end
</code></pre>

<p>  end
end</p>

<h1>For other classes this will be similar to</h1>

<p>class Post
  def self.description</p>

<pre><code>as_json.merge!(commets_counter: true)
</code></pre>

<p>  end
end
{% endcodeblock %}
If subject will not implement description than rails will raise an exception.
Next iteration of refactoring
{% codeblock lang:ruby %}
class Presenter
  def description(subject)</p>

<pre><code>subject.description
</code></pre>

<p>  end
end
{% endcodeblock %}
Congratulation you successfully implement Duck type :)
But now our presenter looks like <a href="http://sourcemaking.com/refactoring/lazy-class">lazy class</a>.
So this class could be totally removed.</p>

<h2>Resume</h2>

<p>If something looks like a duck and quack like a duck than it is a duck.
Also it will be good to test such Ducks using rspec <a href="https://www.relishapp.com/rspec/rspec-core/docs/example-groups/shared-examples">shared_examples</a></p>
]]></content>
  </entry>
  
</feed>
