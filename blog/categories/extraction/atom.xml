<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Extraction | Root of Evil]]></title>
  <link href="http://sharkzp.github.io/blog/categories/extraction/atom.xml" rel="self"/>
  <link href="http://sharkzp.github.io/"/>
  <updated>2013-12-16T18:25:03+02:00</updated>
  <id>http://sharkzp.github.io/</id>
  <author>
    <name><![CDATA[Alex Topalov]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Callbacks Extraction]]></title>
    <link href="http://sharkzp.github.io/blog/2013/12/16/callbacks-extraction/"/>
    <updated>2013-12-16T17:22:00+02:00</updated>
    <id>http://sharkzp.github.io/blog/2013/12/16/callbacks-extraction</id>
    <content type="html"><![CDATA[<p>{% blockquote Edsger W. Dijkstra <a href="http://www.u.arizona.edu/~rubinson/copyright_violations/Go_To_Considered_Harmful.html">http://www.u.arizona.edu/~rubinson/copyright_violations/Go_To_Considered_Harmful.html</a> %}</p>

<p>The unbridled use of the go to statement has an immediate consequence that it becomes terribly hard to find a meaningful set of coordinates in which to describe the process progress.</p>

<p>{% endblockquote %}</p>

<p>Rails provide powerful callback technique and as a powerful tool it could injure in newbie hands.</p>

<!-- more -->


<h3>Understanding the problem</h3>

<p>For example we have simple blog engine. Where we have <code>Posts, Users, Comments</code>
And system should create a default post with random comments when <code>User</code> with type <code>admin</code> created. This could be done through rails callbacks</p>

<p>{% codeblock lang:ruby%}
class User &lt; ActiveRecord::Base
  after_create :create_post, if: :admin?</p>

<p>  private
  def create_post</p>

<pre><code>posts &lt;&lt; Post.create(default_post_attributes)
</code></pre>

<p>  end
end</p>

<p>class Post &lt; ActiveRecord::Base
  after_create :create_comments</p>

<p>  private
  def create_comments</p>

<pre><code>comments &lt;&lt; Comment.create(defaul_comment_attributes)
</code></pre>

<p>  end
end</p>

<p>class Comment &lt; ActiveRecord::Base
  before_create :ensure_user_existance</p>

<p>  private
  def ensure_user_existance</p>

<pre><code>unless user
  user = User.create(default_user_attrubutes)
end
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>After some time passed you decide that creating user for comments was a bad idea and you remove it.
But when you create another one admin you need to search through three different objects to find out why your default post does not have comments. This is the simplest example but you could find even more weird problems and real hell in practice.</p>

<h3>Solution</h3>

<p>For extracting this behavior out of objects we need to keep in mind some of best practices. Sandi Matz recommends to keep your objects unitary and easy to follow check out <a href="http://robots.thoughtbot.com/sandi-metz-rules-for-developers">this</a> blog post for more details.</p>

<p>So lets introduce new object that for now will encapsulate logic around admin user</p>

<p>{% codeblock lang:ruby%}
class AdminUser
  def save</p>

<pre><code>user.save
create_post
</code></pre>

<p>  end</p>

<p>  private
  def create_post</p>

<pre><code>posts &lt;&lt; Post.create(comments: [Comment.create(user: user)])
</code></pre>

<p>  end
end</p>

<p>class User &lt; ActiveRecord::Base
end</p>

<p>class Post &lt; ActiveRecord::Base
end</p>

<p>class Comment &lt; ActiveRecord::Base
end
{% endcodeblock %}</p>

<p>This way we could extract any kind of callbacks out of User class that belongs to specific type of user of certain conditions.</p>

<p>{% codeblock lang:ruby%}
class AdminUser
  attr_reader :attributes</p>

<p>  def initialize(options = {})</p>

<pre><code>before_initialize
attributes = options[:user]
after_initialize
</code></pre>

<p>  end</p>

<p>  def save</p>

<pre><code>before_save
user.save
after_save
</code></pre>

<p>  end</p>

<p>  private
  def user</p>

<pre><code>User.new(attributes)
</code></pre>

<p>  end</p>

<p>  #&hellip;
end
{% endcodeblock %}</p>

<p>I recommend to always keep your objects as clean and small as possible, so any changes that you need to introduce touch single class that easy to understand and follow.</p>

<h3>Resume</h3>

<p>Extracting callbacks out of Domain Class could be useful refactoring technique and any of us should use to avoid callback hells and code smells. Unitary class is much easier to test and change.</p>
]]></content>
  </entry>
  
</feed>
