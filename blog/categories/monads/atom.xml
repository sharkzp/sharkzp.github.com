<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Monads | Root of Evil]]></title>
  <link href="http://sharkzp.github.io/blog/categories/monads/atom.xml" rel="self"/>
  <link href="http://sharkzp.github.io/"/>
  <updated>2013-12-16T18:25:03+02:00</updated>
  <id>http://sharkzp.github.io/</id>
  <author>
    <name><![CDATA[Alex Topalov]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Monads the heart of the matter]]></title>
    <link href="http://sharkzp.github.io/blog/2013/04/27/monads-the-heart-of-the-matter/"/>
    <updated>2013-04-27T12:33:00+03:00</updated>
    <id>http://sharkzp.github.io/blog/2013/04/27/monads-the-heart-of-the-matter</id>
    <content type="html"><![CDATA[<h3>Introduction</h3>

<p>Monads came form functional programming like Haskell. And this is not a secret from no-one that Ruby takes some parts from this languages.
So, what is Monad about?</p>

<p>{% blockquote %}
Monad is a structure that represents computations. This allows the programmer to build pipelines that process data in steps, in which each action is decorated with additional processing rules provided by the monad. Today we will create monad and see how it will help us.
{% endblockquote %}</p>

<!-- more -->


<p>Monad is made up of three things:</p>

<ul>
<li>Container for a value.</li>
<li>Wrap the parameter into instance of monad.</li>
<li>Binding functions to the container.</li>
</ul>


<p>Let&rsquo;s create it step by step
{% codeblock lang:ruby%}
class Monad
  def initialize(value)</p>

<pre><code>@v = value
</code></pre>

<p>  end</p>

<p>  def unit(value)</p>

<pre><code>self.class.new(value)
</code></pre>

<p>  end</p>

<p>  def bind(f)</p>

<pre><code>self.unit(f.call(@v))
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>It will produce
{% codeblock lang:ruby%}
  h = { a: { c: { d: { e: 4 } } } }
  Monad.new(h).bind(lambda{|c| c.fetch(:a)}).bind(lambda{|c| c.fetch(:c)})
  #=> {:d=>{:e=>4}}</p>

<p>  v = 10
  Monad.new(v).bind(lambda{|c| c**2 }).bind(lambda{|c| c / 2 })
  #=> 50
{% endcodeblock %}</p>

<p>This is the basic realization of IO Monads.</p>

<h3>There are few other types.</h3>

<ol>
<li>IO Monad &ndash; take result from first function and pass it to second.</li>
<li>Maybe &ndash; if first function return value than pass it to second function, otherwise return nil. This one implemented as a gem <a href="https://github.com/pzol/monadic">This link</a>.</li>
<li>Either monad &ndash; if function will fail it will return Failure object, otherwise it will return success. This used for handling errors and fighting exceptions.
And others.</li>
</ol>


<h3>Simple implementation of Maybe monad</h3>

<p>{% codeblock lang:ruby%}
class Monad
  def initialize(value)</p>

<pre><code>@v = value
</code></pre>

<p>  end</p>

<p>  def unit(value)</p>

<pre><code>self.class.new(value)
</code></pre>

<p>  end</p>

<p>  def bind(f)</p>

<pre><code>begin
  self.unit(f.call(@v))
rescue
  self.unit(nil)
end
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>It will produce
{% codeblock lang:ruby%}
h1 = { a: { c: { d: { e: 4 } } } }
h2 = {}
f1 = lambda {|c| c.fetch(:a) }
f2 = lambda {|c| c.fetch(:c) }
f3 = lambda {|c| c.fetch(:d) }
f4 = lambda {|c| c.fetch(:e) }</p>

<p>Monad.new(h1).bind(f1).bind(f2).bind(f3).bind(f4)</p>

<h1>=> 4</h1>

<p>Monad.new(h2).bind(f1).bind(f2).bind(f3).bind(f4)</p>

<h1>=> nil</h1>

<p>{% endcodeblock %}
This way you could avoid exception handling in you applications that depend on external request
For example
{% codeblock lang:ruby%}
class TwitterCallbackController &lt; ActionController::Base
  def create</p>

<pre><code>if partner_uuid = Monad.new(request).fetch(:body).fetch(:partner_uuid)
  User.authenticate_by_uuid(partner_uuid)
end
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<h3>Other fields of interest:</h3>

<ul>
<li>Fetching Data from Database</li>
<li>Processing XML/SOAP results</li>
<li>Complex calculations</li>
<li>etc</li>
</ul>


<h2>Resume</h2>

<p>Monad its a powerful technique that could be used in your application in various places. But it could encapsulate some intermediate results that you may want to see. For example error handling could be more useful when you will see real answer from 3rd party applications.</p>
]]></content>
  </entry>
  
</feed>
