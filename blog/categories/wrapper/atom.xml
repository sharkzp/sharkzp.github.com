<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Wrapper | Root of Evil]]></title>
  <link href="http://sharkzp.github.io/blog/categories/wrapper/atom.xml" rel="self"/>
  <link href="http://sharkzp.github.io/"/>
  <updated>2013-12-16T18:25:03+02:00</updated>
  <id>http://sharkzp.github.io/</id>
  <author>
    <name><![CDATA[Alex Topalov]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Refactoring Wrappers]]></title>
    <link href="http://sharkzp.github.io/blog/2013/08/25/refactoring-wrappers/"/>
    <updated>2013-08-25T20:11:00+03:00</updated>
    <id>http://sharkzp.github.io/blog/2013/08/25/refactoring-wrappers</id>
    <content type="html"><![CDATA[<h3>Introduction</h3>

<p>Very often in my everyday practice I faced a task when you need to create a communication between your own services or some 3rd party service that don&rsquo;t have a implementation yet. So what is the best way to doing that?</p>

<p>{% blockquote %}
Wrapper &ndash; it is a piece of code that will be responsible for communication between your application and external service.
{% endblockquote %}</p>

<!-- more -->


<h3>Identicating problem</h3>

<p>When you have a task that implies creation of wrapper you could came up with the easiest solution like:</p>

<p>{% codeblock lang:ruby%}
class ServiceWrapper
  def self.server_rise(server)</p>

<pre><code>request = Net::HTTP.post_form(URI(Settings.service_url + "server_rise"), { server_name: server.name })
if request['success']
  true
else
  false
end
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>But as everyone knew requirements are changes often :) So this could be finished like this:</p>

<p>{% codeblock lang:ruby%}
class ServiceWrapper
  def self.server_rise(server)</p>

<pre><code>request = Net::HTTP.post_form(service_url("server_rise"), { server_name: server.name })
if request['success']
  true
else
  false
end
</code></pre>

<p>  end</p>

<p>  def self.add_platform(platform)</p>

<pre><code>request = Net::HTTP.post_form(service_url("add_platform"), { platform: platform.name})
if request['success']
  request['response']
else
  false
end
</code></pre>

<p>  end</p>

<p>  def self.platform_rise(platform)</p>

<pre><code>request = Net::HTTP.post_form(service_url("platform_rise"), { platform: platform.name})
if request['success']
  true
else
  false
end
</code></pre>

<p>  end</p>

<p>  def exceed_storage(server)</p>

<pre><code>request = Net::HTTP.post_form(service_url("exceed_storage"), { server_name: server.name })
if request['success']
  request['response']
else
  false
end
</code></pre>

<p>  end</p>

<p>  def three_fourths_traffic(server)</p>

<pre><code>request = Net::HTTP.post_form(service_url("three_fourths_traffic"), { server_name: server.name })
if request['success']
  request['response']
else
  false
end
</code></pre>

<p>  end</p>

<p>  def exceed_traffic(server)</p>

<pre><code>request = Net::HTTP.post_form(service_url("exceed_traffic"), { server_name: server.name })
if request['success']
  request['response']
else
  false
end
</code></pre>

<p>  end</p>

<p>  def server_down(server)</p>

<pre><code>request = Net::HTTP.post_form(service_url("server_down"), { server_name: server.name })
if request['success']
  request['response']
else
  false
end
</code></pre>

<p>  end</p>

<p>  private
  def self.service_url(url, options)</p>

<pre><code>URI(Settings.service_url + command)
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>This doesn&rsquo;t even looks like a object oriented approach, this is complete mess that could be extended became even worse. So what we could do about that?</p>

<h3>Understanding problem</h3>

<p>When you develop application especially application in ruby(You remember that this is Object Oriented language, right?) you should keep in mind what objects you create and how messages goes thought them. Let&rsquo;s indicate our objects regarding this task scope:</p>

<ul>
<li>Server</li>
<li>Platform</li>
<li>Notification</li>
</ul>


<p>So basically we have:</p>

<ul>
<li>Initiate Server creation ( isn&rsquo;t this sounds like <code>Object#new</code>? )</li>
<li>Server down ( isn&rsquo;t this changing the state of object ? )</li>
<li>Same for platform</li>
<li>Simple notifications that actually could be treated exactly how you think about your <a href="http://guides.rubyonrails.org/action_mailer_basics.html">mailers</a></li>
</ul>


<h3>Solution</h3>

<p>Now we see what objects we have, lets write simple implementations for <code>Server</code>.</p>

<p>{% codeblock lang:ruby%}
class Wrapper::Server
  def new(server)</p>

<pre><code>@server = server
</code></pre>

<p>  end</p>

<p>  def self.save!</p>

<pre><code>response = Wrapper::Request.post("server_rise", server_name: @server.name)
response.success?
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>From your code it will looks like this <code>Wrapper::Server.new(@server).save!</code> name it as a <code>wrapper</code> is a bad idea, so you should probably name it with a service_name and add Wrapper and the end if necessary. Let&rsquo;s see how <code>request</code> will looks like:</p>

<p>{% codeblock lang:ruby%}
module Wrapper::Request
  class Error &lt; StandardError; end</p>

<p>  def self.post(url, params = {})</p>

<pre><code>response = RestClient.post(Settings.service_url + url, params.to_json, content_type: :json, accept: :json)
Wrapper::Response.new(response.body)
</code></pre>

<p>  rescue RestClient::Exception => e</p>

<pre><code>Wrapper::Response.new(e.response)
</code></pre>

<p>  rescue Errno::ECONNREFUSED => e</p>

<pre><code>raise Wrapper::Request::Error, "Service is down"
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>And <code>response</code></p>

<p>{% codeblock lang:ruby%}
class Wrapper::Response
  def initialize(json_body)</p>

<pre><code>json_body = json_body
</code></pre>

<p>  end</p>

<p>  def success?</p>

<pre><code>!!json_body['response']
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>This is just a proof of concept that will give your a direction in which you should move on. Now you will works with objects instead of hacks.</p>

<h3>Conclusion</h3>

<p>You should always treat your messages as a communication between objects. Even if coding in this way takes more time. But the more time your spend today the less time you will need to spend in future.</p>
]]></content>
  </entry>
  
</feed>
